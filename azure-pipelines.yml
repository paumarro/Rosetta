# Improved Azure Pipeline with Proper Load Testing Isolation
# This is the recommended implementation following CI/CD best practices

trigger:
  branches:
    include:
      - main
      - dev
  paths:
    include:
      - services/*
      - apps/*
      - docker/*

pr:
  branches:
    include:
      - main
      - dev

variables:
  - name: azureSubscription
    value: '076663e1-eb60-4e0e-8a07-45dc414dffd0'
  - name: resourceGroup
    value: 'rg-rosetta'
  - name: containerRegistry
    value: 'rosettaacr.azurecr.io'
  - name: acrName
    value: 'rosettaacr'
  - name: tag
    value: '$(Build.BuildId)'

stages:
  # ============================================
  # STAGE 1: BUILD & UNIT TEST (Fast Feedback)
  # ============================================
  - stage: BuildAndTest
    displayName: 'Build and Unit Tests'
    jobs:
      - job: BuildBackend
        displayName: 'Build Backend (Go)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: GoTool@0
            displayName: 'Install Go'
            inputs:
              version: '1.21'

          - script: |
              cd services/backend
              go mod download
              go test ./... -v -coverprofile=coverage.out
              go build -o main ./cmd/main.go
            displayName: 'Test and build backend'

      - job: BuildAuthService
        displayName: 'Build Auth Service (Go)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: GoTool@0
            displayName: 'Install Go'
            inputs:
              version: '1.21'

          - script: |
              cd services/auth-service
              go mod download
              go test ./... -v
              go build -o main ./cmd/main.go
            displayName: 'Test and build auth service'

      - job: BuildBackendEditor
        displayName: 'Build Backend Editor (Node.js)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - script: |
              cd services/backend-editor
              npm ci
              npm run build
              npm test
            displayName: 'Test and build backend-editor'

      - job: BuildFrontend
        displayName: 'Build Frontend (React)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - script: |
              cd shared && npm install
              cd ../apps/frontend
              npm ci
              npm run build
              npm run lint
            displayName: 'Build and lint frontend'

      - job: BuildFrontendEditor
        displayName: 'Build Frontend Editor (React)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - script: |
              cd shared && npm install
              cd ../apps/frontend-editor
              npm ci
              npm run build
            displayName: 'Build frontend-editor'

  # ============================================
  # STAGE 2: PERFORMANCE TESTS (Isolated)
  # ============================================
  - stage: PerformanceTests
    displayName: 'Performance & Load Tests'
    dependsOn: BuildAndTest
    condition: succeeded()

    jobs:
      # Quick smoke test - runs on all branches
      - job: LoadTestQuick
        displayName: 'Load Test - Quick (5 bots, 30s)'
        condition: always()
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
              docker-compose -f docker-compose.loadtest.yml build
            displayName: 'Build test environment'

          - script: |
              export BOT_COUNT=5
              export TEST_DURATION=30
              export INITIAL_NODE_COUNT=3

              docker-compose -f docker-compose.loadtest.yml up \
                --abort-on-container-exit \
                --exit-code-from loadtest
            displayName: 'Run quick load test'
            timeoutInMinutes: 10

          - script: |
              docker-compose -f docker-compose.loadtest.yml down -v
            displayName: 'Cleanup'
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish results'
            inputs:
              pathToPublish: 'test-results'
              artifactName: 'load-test-quick-results'
            condition: succeededOrFailed()

      # Medium test - runs on main branch
      - job: LoadTestMedium
        displayName: 'Load Test - Medium (20 bots, 60s)'
        condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
              docker-compose -f docker-compose.loadtest.yml build
            displayName: 'Build test environment'

          - script: |
              export BOT_COUNT=20
              export TEST_DURATION=60
              export INITIAL_NODE_COUNT=10

              docker-compose -f docker-compose.loadtest.yml up \
                --abort-on-container-exit \
                --exit-code-from loadtest
            displayName: 'Run medium load test'
            timeoutInMinutes: 15

          - script: |
              # Collect container logs for debugging
              docker-compose -f docker-compose.loadtest.yml logs > container-logs.txt
            displayName: 'Collect container logs'
            condition: always()

          - script: |
              docker-compose -f docker-compose.loadtest.yml down -v
            displayName: 'Cleanup'
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish results'
            inputs:
              pathToPublish: 'test-results'
              artifactName: 'load-test-medium-results'
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish container logs'
            inputs:
              pathToPublish: 'container-logs.txt'
              artifactName: 'load-test-medium-logs'
            condition: succeededOrFailed()

      # Heavy test - manual trigger only
      - job: LoadTestHeavy
        displayName: 'Load Test - Heavy (50 bots, 120s)'
        condition: eq(variables['Build.Reason'], 'Manual')
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
              docker-compose -f docker-compose.loadtest.yml build
            displayName: 'Build test environment'

          - script: |
              export BOT_COUNT=50
              export TEST_DURATION=120
              export INITIAL_NODE_COUNT=20

              docker-compose -f docker-compose.loadtest.yml up \
                --abort-on-container-exit \
                --exit-code-from loadtest
            displayName: 'Run heavy load test'
            timeoutInMinutes: 20

          - script: |
              docker-compose -f docker-compose.loadtest.yml down -v
            displayName: 'Cleanup'
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish results'
            inputs:
              pathToPublish: 'test-results'
              artifactName: 'load-test-heavy-results'
            condition: succeededOrFailed()

  # ============================================
  # STAGE 3: BUILD DOCKER IMAGES
  # ============================================
  # NOTE: Requires Azure service connection to be authorized
  # To authorize: Project Settings → Service Connections → Authorize pipeline
  - stage: BuildDockerImages
    displayName: 'Build Docker Images'
    dependsOn: PerformanceTests
    condition: |
      and(
        succeeded(),
        eq(variables['Build.SourceBranch'], 'refs/heads/main'),
        ne(variables['SKIP_AZURE_STAGES'], 'true')
      )
    jobs:
      - job: BuildAndPushImages
        displayName: 'Build and Push All Images'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Login to ACR and Build/Push Images'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr login --name $(acrName)

                # Build and push all images
                docker build -t $(containerRegistry)/backend:$(tag) -f services/backend/Dockerfile .
                docker push $(containerRegistry)/backend:$(tag)

                docker build -t $(containerRegistry)/backend-editor:$(tag) -f services/backend-editor/Dockerfile .
                docker push $(containerRegistry)/backend-editor:$(tag)

                docker build -t $(containerRegistry)/auth-service:$(tag) -f services/auth-service/Dockerfile .
                docker push $(containerRegistry)/auth-service:$(tag)

                docker build -t $(containerRegistry)/frontend:$(tag) -f apps/frontend/Dockerfile .
                docker push $(containerRegistry)/frontend:$(tag)

                docker build -t $(containerRegistry)/frontend-editor:$(tag) -f apps/frontend-editor/Dockerfile .
                docker push $(containerRegistry)/frontend-editor:$(tag)

  # ============================================
  # STAGE 4: DEPLOY
  # ============================================
  # NOTE: Requires Azure service connection to be authorized
  # To authorize: Project Settings → Service Connections → Authorize pipeline
  - stage: Deploy
    displayName: 'Deploy to Container Apps'
    dependsOn: BuildDockerImages
    condition: |
      and(
        succeeded(),
        eq(variables['Build.SourceBranch'], 'refs/heads/main'),
        ne(variables['SKIP_AZURE_STAGES'], 'true')
      )
    jobs:
      - job: DeployContainerApps
        displayName: 'Update Container Apps'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Deploy to Azure Container Apps'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az containerapp update --name backend --resource-group $(resourceGroup) --image $(containerRegistry)/backend:$(tag)
                az containerapp update --name backend-editor --resource-group $(resourceGroup) --image $(containerRegistry)/backend-editor:$(tag)
                az containerapp update --name auth-service --resource-group $(resourceGroup) --image $(containerRegistry)/auth-service:$(tag)
                az containerapp update --name frontend --resource-group $(resourceGroup) --image $(containerRegistry)/frontend:$(tag)
                az containerapp update --name frontend-editor --resource-group $(resourceGroup) --image $(containerRegistry)/frontend-editor:$(tag)
