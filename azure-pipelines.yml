# Azure Pipeline for Rosetta Monorepo
# Improved with Docker Compose isolation and separated test stages

trigger:
  branches:
    include:
      - main
      - dev
  paths:
    include:
      - services/*
      - apps/*
      - docker/*

pr:
  branches:
    include:
      - main
      - dev

variables:
  - name: azureSubscription
    value: '076663e1-eb60-4e0e-8a07-45dc414dffd0'
  - name: resourceGroup
    value: 'rg-rosetta'
  - name: containerRegistry
    value: 'rosettaacr.azurecr.io'
  - name: acrName
    value: 'rosettaacr'
  - name: tag
    value: '$(Build.BuildId)'
  - name: SKIP_AZURE_STAGES
    value: 'true'  # Set to 'false' when Azure service connection is authorized

stages:
  # ============================================
  # STAGE 1: BUILD & UNIT TEST (Fast Feedback)
  # ============================================
  - stage: BuildAndTest
    displayName: 'Build and Unit Tests'
    jobs:
      # -------------------------------------
      # Backend (Go)
      # -------------------------------------
      - job: BuildBackend
        displayName: 'Build Backend (Go)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1
          
          - task: GoTool@0
            displayName: 'Install Go'
            inputs:
              version: '1.21'
          
          - script: |
              cd services/backend
              go mod download
              go mod verify
            displayName: 'Download Go dependencies'
          
          - script: |
              cd services/backend
              go test ./... -v -coverprofile=coverage.out
            displayName: 'Run Go tests'
          
          - script: |
              cd services/backend
              go build -o main ./cmd/main.go
            displayName: 'Build Go binary'
          
          - task: PublishTestResults@2
            displayName: 'Publish test results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/test-results.xml'
              failTaskOnFailedTests: true
            condition: succeededOrFailed()
          
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: 'services/backend/coverage.out'
            condition: succeededOrFailed()

      # -------------------------------------
      # Auth Service (Go)
      # -------------------------------------
      - job: BuildAuthService
        displayName: 'Build Auth Service (Go)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1
          
          - task: GoTool@0
            displayName: 'Install Go'
            inputs:
              version: '1.21'
          
          - script: |
              cd services/auth-service
              go mod download
              go test ./... -v
              go build -o main ./cmd/main.go
            displayName: 'Build auth service'

      # -------------------------------------
      # Backend Editor (Node.js)
      # -------------------------------------
      - job: BuildBackendEditor
        displayName: 'Build Backend Editor (Node.js)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1
          
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'
          
          - script: |
              cd services/backend-editor
              npm ci
            displayName: 'Install dependencies'
          
          - script: |
              cd services/backend-editor
              npm run build
            displayName: 'Build TypeScript'
          
          - script: |
              cd services/backend-editor
              npm test
            displayName: 'Run tests'
            condition: succeededOrFailed()

      # -------------------------------------
      # Frontend (React)
      # -------------------------------------
      - job: BuildFrontend
        displayName: 'Build Frontend (React)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1
          
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - script: |
              cd shared
              npm install
            displayName: 'Install shared package dependencies'

          - script: |
              cd apps/frontend
              npm ci
            displayName: 'Install dependencies'
          
          - script: |
              cd apps/frontend
              npm run build
            displayName: 'Build React app'
          
          - script: |
              cd apps/frontend
              npm run lint
            displayName: 'Run linting'
            condition: succeededOrFailed()
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish frontend build'
            inputs:
              pathToPublish: 'apps/frontend/dist'
              artifactName: 'frontend-build'

      # -------------------------------------
      # Frontend Editor (React)
      # -------------------------------------
      - job: BuildFrontendEditor
        displayName: 'Build Frontend Editor (React)'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1
          
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - script: |
              cd shared
              npm install
            displayName: 'Install shared package dependencies'

          - script: |
              cd apps/frontend-editor
              npm ci
            displayName: 'Install dependencies'
          
          - script: |
              cd apps/frontend-editor
              npm run build
            displayName: 'Build React app'
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish editor build'
            inputs:
              pathToPublish: 'apps/frontend-editor/dist'
              artifactName: 'frontend-editor-build'


  # ============================================
  # STAGE 2: PERFORMANCE TESTS (Isolated)
  # ============================================
  - stage: PerformanceTests
    displayName: 'Performance & Load Tests'
    dependsOn: BuildAndTest
    condition: succeeded()

    jobs:
      # Quick smoke test - runs on all branches
      - job: LoadTestQuick
        displayName: 'Load Test - Quick (5 bots, 30s)'
        condition: always()
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
              docker-compose -f docker-compose.loadtest.yml build
            displayName: 'Build test environment'

          - script: |
              export BOT_COUNT=5
              export TEST_DURATION=30
              export INITIAL_NODE_COUNT=3

              docker-compose -f docker-compose.loadtest.yml up \
                --abort-on-container-exit \
                --exit-code-from loadtest
            displayName: 'Run quick load test'
            timeoutInMinutes: 10

          - script: |
              docker-compose -f docker-compose.loadtest.yml down -v
            displayName: 'Cleanup'
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish results'
            inputs:
              pathToPublish: 'test-results'
              artifactName: 'load-test-quick-results'
            condition: succeededOrFailed()

      # Medium test - runs on main branch
      - job: LoadTestMedium
        displayName: 'Load Test - Medium (20 bots, 60s)'
        condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
              docker-compose -f docker-compose.loadtest.yml build
            displayName: 'Build test environment'

          - script: |
              export BOT_COUNT=20
              export TEST_DURATION=60
              export INITIAL_NODE_COUNT=10

              docker-compose -f docker-compose.loadtest.yml up \
                --abort-on-container-exit \
                --exit-code-from loadtest
            displayName: 'Run medium load test'
            timeoutInMinutes: 15

          - script: |
              docker-compose -f docker-compose.loadtest.yml logs > container-logs.txt
            displayName: 'Collect container logs'
            condition: always()

          - script: |
              docker-compose -f docker-compose.loadtest.yml down -v
            displayName: 'Cleanup'
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish results'
            inputs:
              pathToPublish: 'test-results'
              artifactName: 'load-test-medium-results'
            condition: succeededOrFailed()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish container logs'
            inputs:
              pathToPublish: 'container-logs.txt'
              artifactName: 'load-test-medium-logs'
            condition: succeededOrFailed()

  # ============================================
  # STAGE 3: BUILD DOCKER IMAGES
  # ============================================
  # NOTE: Requires Azure service connection authorization
  # To skip: Set SKIP_AZURE_STAGES=true in pipeline variables
  - stage: BuildDockerImages
    displayName: 'Build Docker Images'
    dependsOn: PerformanceTests
    condition: |
      and(
        succeeded(),
        eq(variables['Build.SourceBranch'], 'refs/heads/main'),
        ne(variables['SKIP_AZURE_STAGES'], 'true')
      )
    jobs:
      - job: BuildAndPushImages
        displayName: 'Build and Push All Images'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Login to ACR and Build/Push Images'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr login --name $(acrName)

                # Build and push all images
                docker build -t $(containerRegistry)/backend:$(tag) -f services/backend/Dockerfile .
                docker push $(containerRegistry)/backend:$(tag)

                docker build -t $(containerRegistry)/backend-editor:$(tag) -f services/backend-editor/Dockerfile .
                docker push $(containerRegistry)/backend-editor:$(tag)

                docker build -t $(containerRegistry)/auth-service:$(tag) -f services/auth-service/Dockerfile .
                docker push $(containerRegistry)/auth-service:$(tag)

                docker build -t $(containerRegistry)/frontend:$(tag) -f apps/frontend/Dockerfile .
                docker push $(containerRegistry)/frontend:$(tag)

                docker build -t $(containerRegistry)/frontend-editor:$(tag) -f apps/frontend-editor/Dockerfile .
                docker push $(containerRegistry)/frontend-editor:$(tag)

  # ============================================
  # STAGE 4: DEPLOY TO CONTAINER APPS
  # ============================================
  # NOTE: Requires Azure service connection authorization
  # To skip: Set SKIP_AZURE_STAGES=true in pipeline variables
  - stage: Deploy
    displayName: 'Deploy to Container Apps'
    dependsOn: BuildDockerImages
    condition: |
      and(
        succeeded(),
        eq(variables['Build.SourceBranch'], 'refs/heads/main'),
        ne(variables['SKIP_AZURE_STAGES'], 'true')
      )
    jobs:
      - job: DeployContainerApps
        displayName: 'Update Container Apps'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Deploy to Azure Container Apps'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az containerapp update --name backend --resource-group $(resourceGroup) --image $(containerRegistry)/backend:$(tag)
                az containerapp update --name backend-editor --resource-group $(resourceGroup) --image $(containerRegistry)/backend-editor:$(tag)
                az containerapp update --name auth-service --resource-group $(resourceGroup) --image $(containerRegistry)/auth-service:$(tag)
                az containerapp update --name frontend --resource-group $(resourceGroup) --image $(containerRegistry)/frontend:$(tag)
                az containerapp update --name frontend-editor --resource-group $(resourceGroup) --image $(containerRegistry)/frontend-editor:$(tag)

